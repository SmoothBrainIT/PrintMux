You are an expert senior software engineer tasked with building an open-source application called PrintMux.

Your job is to implement a middleware service that presents itself as an OctoPrint-compatible server to slicers, while internally routing uploaded print jobs to one or more real OctoPrint instances selected by the user through a web interface.

Core Requirements

1. OctoPrint Compatibility
- Implement a minimal but functional subset of OctoPrint’s REST API
- Support file uploads from slicers
- Support “upload” and “upload and print” workflows
- Return sane, static, or simplified responses where full fidelity is unnecessary
- Authentication via API key

2. Job Handling
- Store uploaded GCODE or 3MF files on disk
- Create a Job record for each upload
- Track job lifecycle states
- Allow a job to target multiple printers

3. Printer Dispatch
- Integrate with real OctoPrint servers using their REST APIs
- Upload files to downstream printers
- Optionally start prints
- Track per-printer success and failure independently

4. Web Interface
- Display uploaded jobs
- Highlight the most recent job
- Allow selecting one or more printers per job
- Provide actions:
  - Upload only
  - Upload and start print
- Show printer and job status

5. Architecture Constraints
- Backend must use Python and FastAPI
- Frontend must use React
- Database should use SQLAlchemy models
- Background work must be asynchronous
- System must be Docker-friendly
- No cloud dependencies

6. Code Quality Expectations
- Clear module boundaries
- Typed interfaces where possible
- Explicit error handling
- Readable, maintainable code
- Comments explaining non-obvious behavior
- Avoid overengineering

7. Explicit Non-Goals
- No webcam streaming
- No GCODE visualization
- No full OctoPrint state emulation
- No live terminal passthrough

Implementation Guidance

- Treat PrintMux as a “virtual OctoPrint”
- Do not proxy arbitrary OctoPrint endpoints
- Only implement endpoints required for slicer uploads and print starts
- Prefer clarity over completeness
- Build for correctness first, performance second

Deliverables

- Backend FastAPI application with OctoPrint-compatible endpoints
- Dispatcher logic for multi-printer routing
- Database models and migrations
- Minimal but functional React frontend
- Docker Compose setup for local development
- Clear README instructions

Assumptions You May Make

- Printers are reachable on the same network
- Users are technically competent
- Single-user system for initial versions
- Trust boundary is local network

When uncertain, choose the simplest reasonable implementation that satisfies slicer compatibility and job routing.

Begin by implementing the backend core and OctoPrint-compatible upload flow before UI polish.
